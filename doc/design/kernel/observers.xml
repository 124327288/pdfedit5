<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>

 <chapter>
  <title>Observers in cobjects</title>
  <para>
          Generic observer mechanism described in previous chapter is used in
          out cobject implementation. IProperty base class implements
          IObserverHandler interface and so all its descendants are responsible
          for notifying about changes. 
  </para>
  <para>
          Observer is noified if with respect on cobject cathegory. If cobject
          is CObjectSimple specialization (like CInt, CReal and so on), it is
          notified on direct value change. In complex type case represented by
          CObjectComplex specialization (CDict, CArray and CStream), it is
          notified when an element is changed by CObjectComplex interface.
  </para>
  <para>
          All cobjects provides BasicChangeContext which contains previous value
          of changed one. Because complex types can add and remove its elements,
          special behaviour is specified. New value given as mandatory parameter
          of notify method may be CNull if element is deleted from comlex type.
          Old value in the context may also CNull if element was added. It is
          imposible to have both of them CNull.
  </para>
  
  <sect1>
   <title>Observers in CPdf</title>
   
   <para>
          CPdf class as PDF file maintainer uses observers for synchronization
          of structures which may be changed in two ways. This may occure
          because all attributes can be accesible through properties (cobjects)
          and also special objects provided by CPdf - CPage for page
          manipulation, COutline for outlines manipulation and so on. Special
          objects keeps logic of concrete entities and manipulates with cobject
          in that way. Property part is without any logic and enables making
          changes which are not covered by special objects. This advantage and
          extensibility is payed by additional synchronization. 
          <note>Property tree doesn't know the way how it was changed).</note>
   </para>
  
    <sect2>
     <title>Page tree synchronization</title>
     <para>
             Page tree, as mentiont above, can be changed from property site of 
             view by making changes directly to the tree or by CPdf using 
             <programlisting>
             CPdf::insertPage
             Cpdf::removePage
             </programlisting>
             methods. Second way is safer, because all necessary warkaround are 
             done correctly here which is not guaranteed by property site, where 
             any kind of data can be supplied.
     </para>
     <para>
             To handle this situation, each intermediate node in page tree has 
             observer registered to Kids array field and also to all referencies 
             which are in this array. CPdf uses PageTreeWatchDog inner class.
             In short, this method:
	    <orderedlist numeration="arabic">
             <listitem>registers itself to new value (if it is reference of 
                     course). If new value reference points to intermediate node
                     registers also to all children (recursively). This will 
                     guarantee, that next time value is changed, observer will
                     be called and so change can be handled (we don't trust that
                     someone else do it).
             </listitem>
             <listitem>consolidates page tree. It starts from new value and 
                     checks Count field whether it has correct value and whether 
                     all <emphasis>direct</emphasis> children have Parent field 
                     with reference to new value. All bad values are corrected. 
                     Then it uses same process to new value's parent. This will 
                     propagate changes up to page tree root node.
                     As a result intermediate node's Count field contains correct
                     value and also all nodes contain correct reference to their
                     parents.
             </listitem>
             <listitem>Cleans up oldValue reference from given context. This 
                     means, that all pages (CPage instances which contains 
                     dictionary which is referenced by oldValue reference) are 
                     removed from pages list and invalidated. oldValue may stand
                     for intermediate node to, so part of tree may be destroyed.
                     As a result, no page which has been removed because 
                     oldValue has been removed is no longer valid and present in
                     CPdf internal structures.
             </listitem>
             <listitem>
                     Consolidates pages list, becase removing oldValue or adding 
                     newValue may produce different numbering of already existing
                     pages. All pages which dictionary can't get actual position
                     are invalidated too.
                     <note>This may happen if page tree becomes ambiguous, because
                             someone has added reference to this page to the Kids
                             array again and so mapping from dictionary to 
                             position is not possible
                     </note>
                     All other pages are just repositioned. This means that their
                     position (key in the pages list) is accureted to have correct
                     value.
             </listitem>
            </orderedlist>
             Observer must be registered on Kids and also its element too because
             change may be done by setProperty on kids array property or directly
             on reference. Changing indirect object pointed by some reference is 
             ok, because it doesn't make any change in page tree.
             <note>
                     Unless Kids or Count fields are changed. Which results pdf 
                     content destruction. Normaly user is not / should not be able
                     to change such data.
             </note>
     </para>
    </sect2>
    
    <sect2>
     <title>Outlines synchronozation</title>
     <para>
     </para>
    </sect2>
    
  </sect1>
  </chapter>
  
</book>
