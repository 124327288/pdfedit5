<!-- vim:tabstop=4:shiftwidth=4:noexpandtab:textwidth=80 
-->
<sect1>
<title>Observers in cobjects</title>
<para>
  Generic observer mechanism described in <xref linkend="general_utils_observers"/> 
  is used in our cobject implementation. IProperty base class implements
  IObserverHandler interface and so all its descendants are responsible
  for notifying about changes (see <xref linkend="kernel_part_cobjects"/>. 
</para>
<para>
  All cobjects provides BasicChangeContext which contains previous value
  of changed one. Because complex types can add and remove its elements,
  special behaviour is specified. New value given as mandatory parameter
  of notify method may be CNull if element is deleted from comlex type.
  Old value in the context may also CNull if element was added. It is
  imposible to have both of them CNull.
</para>
</sect1>

<sect1>
<title>Observers in CPdf</title>
<para>
  CPdf class as PDF file maintainer uses observers for synchronization
  of structures which may be changed in two ways. This may occure
  because all attributes can be accesible through properties (cobjects)
  and also special objects provided by CPdf - CPage for page
  manipulation, COutline for outlines manipulation and so on. Special
  objects keeps logic of concrete entities and manipulates with cobject
  in that way. Property part is without any logic and enables making
  changes which are not covered by special objects. This advantage and
  extensibility is payed by additional synchronization. 
  <note>Property tree doesn't know the way how it was changed).</note>
</para>

<sect2>
<title>Page tree synchronization</title>
<para>
     Page tree, as mentiont above, can be changed from property site of 
     view by making changes directly to the tree or by CPdf using 
<programlisting>
	CPdf::insertPage
	Cpdf::removePage
</programlisting>
     methods. Second way is safer, because all necessary workaround are 
     done correctly here which is not guaranteed by property site, where 
     any kind of data can be supplied.
</para>
<para>
	To handle this situation <emphasis>TODO</emphasis>
</para>
</sect2>
</sect1>

<sect1>
	<title>Observers in CPage</title>
	<sect2>
		<title>Observer for content stream</title>
		<para>
			TODO Jozo - describe Observer implementation - maybe some image whould be good 
		</para>
	</sect2>
	<sect2>
		<title>Observer for annotation</title>
		<para>
			CPage stores all CAnnotation instance from its Annots array in 
			internal <emphasis>annotStorage</emphasis>. User can change
			annotatations with <emphasis>addAnnotation</emphasis> or
			<emphasis>delAnnotation</emphasis> methods but also by changing
			Annots array directly. 
		</para>
		<para>
			To prevent from problems with inconsistency, CPage instance
			registers <emphasis>AnnotsArrayWatchDog</emphasis> observer
			implementation on Annots array and all its members (because they are
			referencies and someone may change reference value to target which
			is not annotation dictionary). Whenever this array changes,
			observer will force to reload annotStorage (see doxygen
			documentation for more precise information because they are out of
			scope of this documentation).
		</para>
	</sect2>
</sect1>

<sect1 id="kernel_part_ccontentstream_observers">
	<title>Observers in CContentStream</title>
	<para>
		Content stream object uses observer TODO Jozo - describe Observer
		implementation - maybe some image whould be good 
	</para>
</sect1>
