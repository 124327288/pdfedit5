<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>

 <chapter>
  <title>Changes to pdf document</title>
  <para>
        As mentioned before (TODO link), pdf document is represented by number 
        of objects. Most of these objects (with exception of document trailer) 
        are so called indirect objects. Those are accessibly by cross reference 
        table which provides with object and generation number mapping to file 
        offset where such object is stored. 
  </para>
  <para>
        Pdf format enables document changes natively by so called incremental
        update mechanism. This enables to have several cross reference tables 
        each describing objects specific for that revision. All objects which
        have to be changed are just writen to the end of file with new cross 
        reference table which describes this new object. All pdf files viewers
        should be awared of incremental update and if object is accessible from
        several cross reference tables, the newest one is always used. 
  </para>
  <para>
        Previous very short describtion says that making changes requires take
        over of cross reference table manipulation. This has to be done 
        transparently that the nobody knows that object is changed actualy.
  </para>
  <sect1>
    <title>3 layer model</title>
    <para>
        Cross reference table is mantained by XRef class in xpdf code. This 
        class keeps just table of this information and it is not designed to 
        be extensible for making changes very well. So we have reused this 
        class as lowest layer in our 3 layer model designed to enable making 
        changes to document. This XRef layer keeps logic of pdf file parsing
        and correct assignment of object referencies (object and generation
        number) and objects.
    </para>
    <para>
        To enable this reusability in C++ language we had to make some minor 
        changes to xpdf code, basicaly prepare them for transparent dynamic 
        inheritance, so all neccessary methods were virtualized and also data 
        fields turned to protected (from private). (TODO link to xpdf_changes
        document).
    </para>
    <para>
        Second layer model layer is formed by CXref - extension of XRef class. 
        Prime responsibility is to create methods which can register changes and
        keeps them available. All methods which enables making changes are not
        public to hide them from normal usage (see below for reason). It 
        overwrites public methods from XRef and always use changed objects
        if they are avialable. Otherwise delegates to lower layer. This aproach
        enables to use CXref transparently anytime when XRef instance is 
        required (e. g. in rest of xpdf code which may be reuseable) with 
        advantage of access to changed values without any special logic from
        class user. To prevent inconsistencies and to make usage and 
        implementation easier, all methods providing change functionality are
        protected. They are implemented without any special logic. All changes
        are stored to the mapping where they can be accessible. No special
        checking is performed. It is also safe to return CXref instance, because
        it is guarantied that nobody can use this class to make chages.
    </para>
    <para>
        Highest layer is represented by XRefWriter class - extension of CXref 
        class. It's responsibility is to keep logic upon changes, to enable
        writing them to the file and to maintain revisions of the document. 
        Logic upon changes means some type checking to prevent object type 
        inconsistency. XRefWriter defines mode in which it works to control
        checking mechanism. Second responsibility is to enable writing changes
        to the file to make them visible after all required changes are 
        finished. To separate from concrete implementation of storing, XRefWriter
        uses IPdfWriter abstract interface for object writing. Concrete 
        implementation can be set in runtime and OldStylePdfWriter is used
        by default. XRefWriter is just responsible to provide with all changed
        objects which are retrieved from lower (CXref) layer.     
    </para>
    <para>
        PDF format is prepared for such revision and multi version documents 
        very well, but doesn't support any kind of branching which means that
        changes can be done only for newest revision. XRefWriter take in mind
        also this aspect and so all methods take care of current revision.
    </para>
    <para>
        For more information about responsibility and functionality separation
        see following figure.
 	<mediaobject>
	  <imageobject>
	   <imagedata fileref="images/xref_layer_diagram" format="PNG"/>
	  </imageobject>
	  <textobject><phrase>3 layers diagram</phrase></textobject>
	  <caption><para>3 layers diagram</para></caption>
	</mediaobject>
  </para>
  </sect1>
  <sect1>
   <title>Document saving</title>
   <para>
        As it was mantioned above, PDF format supports changes in document in so 
        called incremental update (all changed objects are appened to document 
        end and new cross reference table for changed objects with new trailer 
        - just to repete in short). This means that each set of changes forms new 
        revision. This brings little task to think about. What should be stored in 
        one revision and which changes are not worth of new revision?
        User usually wants to save everything because
        of fear of data lost and doesn't thing about some revisions. If each save
        created it would lead to mess with horible number of referencies without
        any meaning.
   </para>
   <sect2>
   <title>Revision saving</title>
   <para>
        XRefWriter provides save functionality with flag. This flag sais how data
        should be stored with respect to revisions:
        <listitem>temporal saving, which dumps all changes with correct cross 
                reference table and trailer at the end of document but doesn't
                care for it (no internal structures are touch and they are kept
                as if no save has been done). If any problem occures changed data
                are stored, so no data lost happens. Whenever save is done again
                it will rewrite older temporarily saved changes.
        </listitem>
        <listitem>revision saving, which do the very same as previous one except
                all internal structures are prepared to state as if this document
                was opend again after saving. This means that we are working on 
                freshly created revision after saving. This makes sense when 
                user knows that changes made by him are gathered together in one
                revision and nothing else messes with it.
        </listitem>
        It is up to user to use the way how he wants to save changes. However 
        temporal changes are default and new revision saving is done only if
        it is explicitly said.
   </para>
   </sect2>
   <sect2>
   <title>Content writing and IPdfWriter</title>
   <para>
        XRefWriter uses abstract IPdfWriter class to write changed content when
        save method is called. This enables separation of implementation from 
        design. All saving is delegated to pdfWriter implementation holder and 
        it depends on it how content is writen.
   </para>
   <para>
        IPdfWriter writes pdf content in two phases:
        <listitem>Real data writing and information collecting. This is done 
                during writeContent method. Implementator is responsible to 
                collect all data needed for cross reference section generation.
        </listitem>
        <listitem>Cross reference section writing. This is done in writeTrailer
                method, which gets all collected data and writes cross reference
                table (or stream - depends on implementation), writes trailer 
                dictionary and finaly information about last xref position.
        </listitem>
        Different implementator of IPdfWriter interface can be set by 
        XRefWriter::setPdfWriter method.
   </para>
   <para>
        Each sequence of writeContent, [writeContent, ]* writeTrailer forms new
        revision of document in incremental update sense. In this moment 
        OldStylePdfWriter implementation is used which forms old style cross 
        reference table (see pdf specification 2.4.3 Cross reference table chapter
        TODO link).
   </para>
   </sect2>

   <sect2>
    <title>Document cloning</title>
    <para>
        To be able to effectively solve problem with PDF disability to branche 
        document and so making changes to older revisions XRefWriter brings
        so called cloning capability. This means copying document content until
        current revision (including current one). If user wants to change 
        something in such revision, he can switch to that revision and clone 
        it to different file. Changes are enabled to this document, because
        current revision in original document is the newest one in cloned
        document. Nevertheless document merging is not implemented yet, so 
        there is no way (using this program) to get those changes back to main
        document.
    </para>
   </sect2>
  </sect1>
 </chapter>

  
</book>

