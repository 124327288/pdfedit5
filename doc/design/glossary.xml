<!-- vim:tabstop=4:shiftwidth=4:noexpandtab:textwidth=80 
-->
<!-- Each entry of glossary should be defined within glossary tags by
glossentry tags with id used by xref tag in the general text. 
Example:
	<glossary>
		...
		<glossentry id="identificator">
			<glossterm>Term declaration</glossterm>
			<glossdef>
				Term definition/description (it can contain 
				formated text pictures or arbitrary formatted 
				text.
			</glossdef>
		</glossentry>
		...
	</glossary>
-->


<glossary id="glossary_part">
	<glossentry id="adapter">
		<glossterm>Adapter design pattern</glossterm>
		<glossdef>
		<para>
			The adapter design pattern (sometimes referred to as the wrapper 
			pattern or simply a wrapper) 'adapts' one interface for a class 
			into one that a client expects. An adapter allows classes to work 
			together that normally could not because of incompatible interfaces
			by wrapping its own interface around that of an already existing 
			class.
			<mediaobject>
			  <imageobject align="center">
				  <imagedata fileref="images/objectadapter.png" format="PNG"/>
			  </imageobject>
			  <caption><para>Object Adapter</para></caption>
			</mediaobject>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="composite">
		<glossterm>Composite design pattern</glossterm>
		<glossdef>
		<para>
			Composite is an object designed as a composition of one-or-more 
			similar objects (other kinds of shapes/geometries), all exhibiting 
			similar functionality. This is known as a "has-a" relationship 
			between objects. The key concept is that you can manipulate a 
			single instance of the object just as you would a group of them.
			<mediaobject>
			  <imageobject align="center">
				  <imagedata fileref="images/compositepattern.png" format="PNG"/>
			  </imageobject>
			  <caption><para>Composite</para></caption>
			</mediaobject>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="content_stream">
		<glossterm>Content stream</glossterm>
		<glossdef>
		<para>
			TODO
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="crossref_table">
		<glossterm>Cross reference table</glossterm>
		<glossdef>
		<para>
			TODO
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="decorator">
		<glossterm>Decorator design patter</glossterm>
		<glossdef>
		<para>
			The decorator pattern works by wrapping the new "decorator" object 
			around the original object, which is typically achieved by passing 
			the original object as a parameter to the constructor of the 
			decorator, with the decorator implementing the new functionality. 
			The interface of the original object needs to be maintained by the 
			decorator.
			<mediaobject>
			  <imageobject align="center">
				  <imagedata fileref="images/decaratorpattern.png" format="PNG"/>
			  </imageobject>
			  <caption><para>Decorator</para></caption>
			</mediaobject>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="ecmascript">
		<glossterm>ECMAScript</glossterm>
		<glossdef>
		<para>
		ECMAScript is programming language, similar to Javascript (which is in fact extension of ECMAScript).
		The language is standardized by Ecma International as Standard ECMA-262, also approved as ISO/IEC 16262.
		For more details, see the specification:
                </para>
                <para>
                <ulink url="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">ECMAScript Language Specification, 3rd edition (December 1999)</ulink>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="dictionary">
		<glossterm>Pdf dictionary data type</glossterm>
		<glossdef>
		<para>
			TODO
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="document_catalog">
		<glossterm>Pdf document catalog</glossterm>
		<glossdef>
		<para>
			TODO
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="factory_method">
		<glossterm>Factory method design pattern</glossterm>
		<glossdef>
		<para>
			The Factory Method pattern is an object-oriented design pattern. 
			Like other creational patterns, it deals with the problem of 
			creating objects (products) without specifying the exact class 
			of object that will be created. Factory Method, one of the 
			patterns from the Design Patterns book, handles this problem by
			defining a separate method for creating the objects, which 
			subclasses can then override to specify the derived type of 
			product that will be created.
			<mediaobject>
			  <imageobject align="center">
				  <imagedata fileref="images/factorymethodpattern.png" format="PNG"/>
			  </imageobject>
			  <caption><para>Factory method</para></caption>
			</mediaobject>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="facade">
		<glossterm>Facade design pattern</glossterm>
		<glossdef>
		<para>
			The facade pattern is an object-oriented design pattern. A facade 
			is an object that provides a simplified interface to a larger body
			of code, such as a class library.
			<mediaobject>
			  <imageobject align="center">
				  <imagedata fileref="images/facadepattern.gif" format="GIF"/>
			  </imageobject>
			  <caption><para>Facade</para></caption>
			</mediaobject>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="functor">
		<glossterm>Functor</glossterm>
		<glossdef>
		<para>
			In C++ context, functor is method implementing functional operator.
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="gpl">
		<glossterm>GPL - General public licence</glossterm>
		<glossdef>
		<para>
			General public licence created by Free Software Foundation. The 
			purpose of the GPL is to grant any user the right to copy, modify and 
			redistribute programs and source code from developers that have chosen 
			to license their work under the GPL. See <ulink url="http://en.wikipedia.org/wiki/GPL">GPL wiki</ulink> 
			for more information. TODO link to complete licence
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="incremental_update">
		<glossterm>Incremental update</glossterm>
		<glossdef>
		<para>
			TODO
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="indirect_object">
		<glossterm>Indirect pdf object</glossterm>
		<glossdef>
		<para>
			TODO
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="invariant">
		<glossterm>Invariant</glossterm>
		<glossdef>
		<para>
			Invariant is a condition that is always true at a 
			certain point in a program. In context of automatical 
			testing, invariant defines expectation of behavior 
			compared to real result of operation.
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="iterator">
		<glossterm>Iterator design pattern</glossterm>
		<glossdef>
		<para>
			The Iterator pattern defines an interface that declares methods
			for sequentially accessing the objects in a collection. A class
			that accesses a collection only through such an interface remains
			independent of the class that implements the interface.
			<mediaobject>
			  <imageobject align="center">
				  <imagedata fileref="images/iteratorpattern.gif" format="GIF"/>
			  </imageobject>
			  <caption><para>Iterator</para></caption>
			</mediaobject>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="linearized_pdf">
		<glossterm>Linearized pdf document</glossterm>
		<glossdef>
		<para>
			Linearized document is specially optimized pdf document for quick
			viewing without need to have whole document at the time when viewing
			starts.
		</para>
		<para>
			All objects related for first page (or fiew pages) are stored in
			first 1024 bytes and TODO
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="observer">
		<glossterm>Observer design patter</glossterm>
		<glossdef>
		<para>
			The observer pattern (sometimes known as publish/subscribe) is a 
			design pattern used in computer programming to observe the state 
			of an object in a program. It is related to the principle of 
			Implicit invocation.
			<mediaobject>
			  <imageobject align="center">
				  <imagedata fileref="images/observerpattern.jpg" format="JPG"/>
			  </imageobject>
			  <caption><para>Observer</para></caption>
			</mediaobject>
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="page_tree">
		<glossterm>Pdf page tree</glossterm>
		<glossdef>
		<para>
			Pdf stores all page dictionaries organized in so called page tree.
			This tree distinguish 2 types of nodes:
			<itemizedlist>
				<listitem>
					Intermediate tree node - this node's purpose is to collect
					other nodes as a subtree. It is represented by <xref linkend="dictionary"/>
					which contains element with <emphasis>Kids</emphasis> name
					and which contains reference to <xref linkend="indirect_object"/>
					of a node (this node can be either intermediate or page node.
					Intermediate tree node dictionary contains element with 
					<emphasis>Type</emphasis> name and this has to have
					<emphasis>Pages</emphasis> value. To enable travirsing in
					the tree, also <emphasis>Count</emphasis> element is
					required for node's dictionary. This element holds number of
					page tree nodes in current intermediate node.
				</listitem>
				<listitem>
					Page (leaf) tree node - this node contains direct page
					information. It is represented by page dictionary which has
					element with <emphasis>Type</emphasis> name and
					<emphasis>Page</emphasis> value.
				</listitem>
			</itemizedlist>
			Root of the tree is referenced by <xref linkend="document_catalog"/>
			dictionary as <emphasis>Pages</emphasis> element reference. 
		</para>
		<para>
			With well balanced tree, it is possible to access arbitrary page
			(also for very big amount of pages) in very short time (just fiew
			hops through intermediate nodes). Pdf creators usually collects
			pages in chunks in one intermediate node. Also intermediate nodes
			are collected by 10. This means that document with 1000 pages has
			page tree with 3 intermediate nodes.
			<note>
				Page tree root is allways intermediate node.
			</note>
		</para>
		<mediaobject>
		  <imageobject align="center">
			  <imagedata fileref="images/page_tree.png" format="PNG"/>
		  </imageobject>
		  <caption><para>Page tree</para></caption>
		</mediaobject>
		</glossdef>
	</glossentry> 
	<glossentry id="stream">
		<glossterm>pdf stream</glossterm>
		<glossdef>
		<para>
			todo
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="trailer">
		<glossterm>pdf trailer</glossterm>
		<glossdef>
		<para>
			todo
		</para>
		</glossdef>
	</glossentry> 
	<glossentry id="wrapper">
		<glossterm>Wrapper design patter</glossterm>
		<glossdef>
		<para>
			A wrapper converts the interface of a class into another interface
			clients expect. Wrappers let classes work together that couldn't 
			otherwise because of incompatible interfaces.
		</para>
		</glossdef>
	</glossentry> 
</glossary>

